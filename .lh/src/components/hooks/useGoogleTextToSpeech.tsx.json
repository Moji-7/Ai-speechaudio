{
    "sourceFile": "src/components/hooks/useGoogleTextToSpeech.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1706607895269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1706608188740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n import { useState, useEffect } from \"react\";\r\n+import { useQuery, UseQueryResult } from \"@tanstack/react-query\";\r\n \r\n // Define the type for the speech object\r\n type Speech = {\r\n   audioContent: string;\r\n@@ -8,23 +9,16 @@\n export const useGoogleTextToSpeech = (\r\n   ssmlText: string,\r\n   apiKey: string\r\n ): [string, boolean, boolean, () => void] => {\r\n-  // Use state to store the speech object and the loading and error states\r\n-  const [speech, setSpeech] = useState<Speech | null>(null);\r\n-  const [loading, setLoading] = useState<boolean>(false);\r\n-  const [error, setError] = useState<boolean>(false);\r\n-\r\n   // Use state to store the URL from the audio data\r\n   const [url, setUrl] = useState<string>(\"\");\r\n \r\n-  // Use useEffect to call the Google Cloud Text-to-Speech API with the SSML text as the input\r\n-  useEffect(() => {\r\n-    // Define a function to call the API\r\n-    const callAPI = async () => {\r\n-      // Set the loading state to true\r\n-      setLoading(true);\r\n-\r\n+  // Use the useQuery hook to call the Google Cloud Text-to-Speech API with the SSML text as the input\r\n+  const { data, isLoading, isError } = useQuery<Speech, Error>(\r\n+    // Specify the query key as the ssmlText and apiKey\r\n+    [\"useGoogleTextToSpeech\", ssmlText, apiKey],\r\n+    async () => {\r\n       // Define the API endpoint\r\n       const endpoint = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;\r\n \r\n       // Define the request body\r\n@@ -55,39 +49,37 @@\n         });\r\n \r\n         // Check if the response is ok\r\n         if (response.ok) {\r\n-          // Parse the response data as JSON and store it in the state\r\n+          // Parse the response data as JSON and return it\r\n           const data: Speech = await response.json();\r\n-          setSpeech(data);\r\n+          return data;\r\n         } else {\r\n-          // Throw an error with the status and message\r\n+          // Throw an error object with the status and message\r\n           throw new Error(\r\n             `Request failed: ${response.status} ${response.statusText}`\r\n           );\r\n         }\r\n       } catch (error) {\r\n         // Handle the errors that may occur while making the request\r\n-        // Set the error state to true\r\n-        setError(true);\r\n-        // Log the error to the console\r\n-        console.error(error);\r\n-      } finally {\r\n-        // Set the loading state to false\r\n-        setLoading(false);\r\n+        // Check if the error is an instance of Error\r\n+        if (error instanceof Error) {\r\n+          // Throw the error object\r\n+          throw error;\r\n+        } else {\r\n+          // Throw a generic error object\r\n+          throw { status: 500, message: \"Something went wrong\" };\r\n+        }\r\n       }\r\n-    };\r\n+    }\r\n+  );\r\n \r\n-    // Call the API function\r\n-    callAPI();\r\n-  }, [ssmlText, apiKey]);\r\n-\r\n   // Use useEffect to create a URL from the audio data and store it in the state\r\n   useEffect(() => {\r\n-    // Check if the speech object is not null\r\n-    if (speech) {\r\n-      // Get the audio content from the speech object\r\n-      const { audioContent } = speech;\r\n+    // Check if the data object is not undefined\r\n+    if (data) {\r\n+      // Get the audio content from the data object\r\n+      const { audioContent } = data;\r\n \r\n       // Convert the base64-encoded audio data to a blob\r\n       const byteCharacters = atob(audioContent);\r\n       const byteNumbers = new Array(byteCharacters.length);\r\n@@ -100,9 +92,9 @@\n       // Create a URL from the blob and store it in the state\r\n       const url = URL.createObjectURL(blob);\r\n       setUrl(url);\r\n     }\r\n-  }, [speech]);\r\n+  }, [data]);\r\n \r\n   // Define a function to revoke the URL\r\n   const revokeURL = () => {\r\n     // Check if the URL is not empty\r\n@@ -113,6 +105,6 @@\n     }\r\n   };\r\n \r\n   // Return the URL, the loading and error states, and the revokeURL function\r\n-  return [url, loading, error, revokeURL];\r\n+  return [url, isLoading, isError, revokeURL];\r\n };\r\n"
                },
                {
                    "date": 1706609146354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,15 +33,12 @@\n         audioConfig: {\r\n           audioEncoding: \"MP3\",\r\n         },\r\n       };\r\n-\r\n-      // Define the request headers\r\n       const headers = {\r\n         \"Content-Type\": \"application/json\",\r\n       };\r\n \r\n-      // Try to make a POST request to the API endpoint with the headers and body\r\n       try {\r\n         const response = await fetch(endpoint, {\r\n           method: \"POST\",\r\n           headers: headers,\r\n@@ -77,10 +74,9 @@\n   useEffect(() => {\r\n     // Check if the data object is not undefined\r\n     if (data) {\r\n       // Get the audio content from the data object\r\n-      const { audioContent } = data;\r\n-\r\n+      const {audioContent}  = data;\r\n       // Convert the base64-encoded audio data to a blob\r\n       const byteCharacters = atob(audioContent);\r\n       const byteNumbers = new Array(byteCharacters.length);\r\n       for (let i = 0; i < byteCharacters.length; i++) {\r\n"
                }
            ],
            "date": 1706607895269,
            "name": "Commit-0",
            "content": "import { useState, useEffect } from \"react\";\r\n\r\n// Define the type for the speech object\r\ntype Speech = {\r\n  audioContent: string;\r\n};\r\n\r\nexport const useGoogleTextToSpeech = (\r\n  ssmlText: string,\r\n  apiKey: string\r\n): [string, boolean, boolean, () => void] => {\r\n  // Use state to store the speech object and the loading and error states\r\n  const [speech, setSpeech] = useState<Speech | null>(null);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<boolean>(false);\r\n\r\n  // Use state to store the URL from the audio data\r\n  const [url, setUrl] = useState<string>(\"\");\r\n\r\n  // Use useEffect to call the Google Cloud Text-to-Speech API with the SSML text as the input\r\n  useEffect(() => {\r\n    // Define a function to call the API\r\n    const callAPI = async () => {\r\n      // Set the loading state to true\r\n      setLoading(true);\r\n\r\n      // Define the API endpoint\r\n      const endpoint = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;\r\n\r\n      // Define the request body\r\n      const body = {\r\n        input: {\r\n          ssml: ssmlText,\r\n        },\r\n        voice: {\r\n          languageCode: \"en-US\",\r\n          name: \"en-US-Wavenet-A\",\r\n        },\r\n        audioConfig: {\r\n          audioEncoding: \"MP3\",\r\n        },\r\n      };\r\n\r\n      // Define the request headers\r\n      const headers = {\r\n        \"Content-Type\": \"application/json\",\r\n      };\r\n\r\n      // Try to make a POST request to the API endpoint with the headers and body\r\n      try {\r\n        const response = await fetch(endpoint, {\r\n          method: \"POST\",\r\n          headers: headers,\r\n          body: JSON.stringify(body),\r\n        });\r\n\r\n        // Check if the response is ok\r\n        if (response.ok) {\r\n          // Parse the response data as JSON and store it in the state\r\n          const data: Speech = await response.json();\r\n          setSpeech(data);\r\n        } else {\r\n          // Throw an error with the status and message\r\n          throw new Error(\r\n            `Request failed: ${response.status} ${response.statusText}`\r\n          );\r\n        }\r\n      } catch (error) {\r\n        // Handle the errors that may occur while making the request\r\n        // Set the error state to true\r\n        setError(true);\r\n        // Log the error to the console\r\n        console.error(error);\r\n      } finally {\r\n        // Set the loading state to false\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    // Call the API function\r\n    callAPI();\r\n  }, [ssmlText, apiKey]);\r\n\r\n  // Use useEffect to create a URL from the audio data and store it in the state\r\n  useEffect(() => {\r\n    // Check if the speech object is not null\r\n    if (speech) {\r\n      // Get the audio content from the speech object\r\n      const { audioContent } = speech;\r\n\r\n      // Convert the base64-encoded audio data to a blob\r\n      const byteCharacters = atob(audioContent);\r\n      const byteNumbers = new Array(byteCharacters.length);\r\n      for (let i = 0; i < byteCharacters.length; i++) {\r\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n      }\r\n      const byteArray = new Uint8Array(byteNumbers);\r\n      const blob = new Blob([byteArray], { type: \"audio/mpeg\" });\r\n\r\n      // Create a URL from the blob and store it in the state\r\n      const url = URL.createObjectURL(blob);\r\n      setUrl(url);\r\n    }\r\n  }, [speech]);\r\n\r\n  // Define a function to revoke the URL\r\n  const revokeURL = () => {\r\n    // Check if the URL is not empty\r\n    if (url) {\r\n      // Revoke the URL and set the state to empty\r\n      URL.revokeObjectURL(url);\r\n      setUrl(\"\");\r\n    }\r\n  };\r\n\r\n  // Return the URL, the loading and error states, and the revokeURL function\r\n  return [url, loading, error, revokeURL];\r\n};\r\n"
        }
    ]
}